<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.10: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: Your Name
:Contact: Your Email Address
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.  [Optionally place a more
detailed description here.]
*/

@import url(html4css1.css);

/* Your customizations go here.  For example: */
body {
    font-family: sans-serif;
}

dl.docutils dt {
    font-weight: bold
}


</style>
</head>
<body>
<div class="document">


<p>This directory contains some source code examples of how to work with zmq.</p>
<ul class="simple">
<li><a class="reference internal" href="#request-response">Request - Response</a></li>
<li><a class="reference internal" href="#publish-and-subscribe">Publish and Subscribe</a></li>
<li><a class="reference internal" href="#voisietequi-prototype">Voisietequi prototype</a></li>
<li><a class="reference internal" href="#fake-mail-form">Fake mail form</a></li>
</ul>
<div class="section" id="request-response-example">
<span id="request-response"></span><h1>Request - Response example</h1>
<pre class="literal-block">
  #------------#
  |   Client   |
  +------------+
  |    REQ     |
  '---+--------'
      |    ^
      |    |
Hello |    | World
      |    |
      v    |
  .--------+---.
  |    REP     |
  +------------+
  |   Server   |
  #------------#
</pre>
<dl class="docutils">
<dt>reqrep_server.py</dt>
<dd><p class="first">Listens on a <tt class="docutils literal">zmq.REP</tt> socket on port 5556.
Whenever a message is received, after 1 sec, sends a reply, over the same socket:</p>
<pre class="last literal-block">
message = socket.recv()
time.sleep (1)
socket.send(&quot;World from %s&quot; % port)
</pre>
</dd>
<dt>reqrep_client.py</dt>
<dd><p class="first">The client connects to a <tt class="docutils literal">zmq.REQ</tt> socket on port 5556. It loops 10 times, sending a request and
waiting for a response:</p>
<pre class="last literal-block">
socket.send (&quot;Hello&quot;)
message = socket.recv()
</pre>
</dd>
</dl>
</div>
<div class="section" id="publish-subscribe-example">
<span id="publish-and-subscribe"></span><h1>Publish - Subscribe example</h1>
<pre class="literal-block">
               #-------------#
               |  Publisher  |
               +-------------+
               |     PUB     |
               '-------------'
                    bind
                      |
                      |
                   updates
                      |
      .---------------+---------------.
      |               |               |
   updates         updates         updates
      |               |               |
      |               |               |
      v               v               v
   connect         connect         connect
.------------.  .------------.  .------------.
|    SUB     |  |    SUB     |  |    SUB     |
+------------+  +------------+  +------------+
| Subscriber |  | Subscriber |  | Subscriber |
#------------#  #------------#  #------------#
</pre>
<dl class="docutils">
<dt>pub_server.py</dt>
<dd><p class="first">Listens on a <tt class="docutils literal">zmq.PUB</tt> socket on port 5556.
Continuously spits out random temperature data relative to 3 different zipcodes (topics):</p>
<pre class="last literal-block">
zipcode = random.randrange(10000,10002)
messagedata = random.randrange(1,215) - 80
socket.send(&quot;%d %d&quot; % (zipcode, messagedata))
</pre>
</dd>
<dt>sub_client.py</dt>
<dd><p class="first">Connects to a <tt class="docutils literal">zmq.SUB</tt> socket on port 5556. Sets a subscription to one of the three zipcodes (topic).
After receiving 5 messages, computes the average:</p>
<pre class="last literal-block">
socket.setsockopt(zmq.SUBSCRIBE, &quot;10001&quot;)
total_value = 0
for update_nbr in range (5):
    string = socket.recv()
    topic, messagedata = string.split()
    total_value += int(messagedata)
    print topic, messagedata
</pre>
</dd>
</dl>
</div>
<div class="section" id="complex-voisietequi-prototype">
<span id="voisietequi-prototype"></span><h1>Complex Voisietequi prototype</h1>
<p>In Voisietequi there is a <strong>server</strong> which distributes
computation requests over different <strong>computers</strong>. Details can be found on voisietequi
github repository.</p>
<p>Computers must be <em>discovered</em> and <em>configured</em>, by the central server, so that there is no
need to specify configuration settings when launching them.</p>
<p>Computers should also send the results of their computation back to the server, in order to save
the results in a database, for example.</p>
<div class="section" id="configuration-and-discovery">
<h2>Configuration and discovery</h2>
<pre class="literal-block">
               #-------------#
               |    Server   |
               +-------------+
               |     PUB     |
               '-------------'
                  bind:5556
                      |
                      |
                   commands
                      |
      .---------------+---------------.
      |               |               |
   commands        commands        commands
      |               |               |
      |               |               |
      v               v               v
 connect:5556    connect:5556    connect:5556
.------------.  .------------.  .------------.
|    SUB     |  |    SUB     |  |    SUB     |
+------------+  +------------+  +------------+
|  Computer  |  |  Computer  |  |  Computer  |
+------------+  +------------+  +------------+
|    PUSH    |  |    PUSH    |  |    PUSH    |
'-----+------'  '-----+------'  '-----+------'
 connect:5557    connect:5557    connect:5557
      |               |               |
      '---------------+---------------'
                      |
                   results
                      |
                      v
                  bind:5557
               .-------------.
               |    PULL     |
               +-------------+
               |   Server    |
               #-------------#
</pre>
<dl class="docutils">
<dt>command.py</dt>
<dd><p class="first">emulates the vsq-server, there are 2 connections in the same process:</p>
<blockquote>
<ul class="simple">
<li>binds to <tt class="docutils literal">zmq.PUB</tt> socket pn port 5556, to send command to all parties interested</li>
<li>binds to <tt class="docutils literal">zmq.PULL</tt> socket on port 5557, to receive all command response results</li>
</ul>
</blockquote>
<p>a <tt class="docutils literal">configure</tt> command is sent and the reply message is listened to; listening is done
through a <a class="reference external" href="https://learning-0mq-with-pyzmq.readthedocs.org/en/latest/pyzmq/multisocket/zmqpoller.html">poller</a> in the <tt class="docutils literal">cmd_reply_handler</tt> function; once the reply message is found in the poll,
it is consumed and connections are closed:</p>
<pre class="last literal-block">
should_continue = True
while should_continue:
  socks = dict(poller.poll(200))
  if results_receiver in socks and socks[results_receiver] == zmq.POLLIN:
      message = results_receiver.recv()
      print &quot;Computer responded: %s&quot; % message
  else:
      should_continue = False
</pre>
</dd>
<dt>computer.py</dt>
<dd><p class="first">emulates the vsq-computer; it has 2 parallel tasks, running:</p>
<blockquote class="last">
<ul class="simple">
<li><tt class="docutils literal">main_task_handler</tt>: simulates the computation task
sends results of the computation to the <strong>saver</strong>, see next section</li>
<li><tt class="docutils literal">cmd_handler</tt>: handle configuration commands sent by server: connect to a <tt class="docutils literal">zmq.SUB</tt> socket on port 5556
and continuously awaits for commands there, once received, a reply is immediatly sent back through
a connection to a <tt class="docutils literal">zmq.PUSH</tt> on port 5557</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="saving-the-results">
<h2>Saving the results</h2>
<pre class="literal-block">
#------------#  #------------#  #------------#
|  Computer  |  |  Computer  |  |  Computer  |
+------------+  +------------+  +------------+
|    PUSH    |  |    PUSH    |  |    PUSH    |
'-----+------'  '-----+------'  '-----+------'
 connect:5558    connect:5558    connect:5558
      |               |               |
      '---------------+---------------'
                      |
                   results
                      |
                      v
                   bind:5558
               .-------------.
               |    PULL     |
               +-------------+
               |    Server   |
               #-------------#
</pre>
<dl class="docutils">
<dt>computer.py</dt>
<dd><p class="first">emulates the vsq-computer; it has 2 parallel tasks, running:</p>
<blockquote class="last">
<ul>
<li><p class="first"><tt class="docutils literal">main_task_handler</tt>: simulates the computation task
sends results of the computation to the <strong>saver</strong>, connecting to a <tt class="docutils literal">zmq.PUSH</tt> on port 5558:</p>
<pre class="literal-block">
save_sender.send_json(result)
</pre>
</li>
<li><p class="first"><tt class="docutils literal">cmd_handler</tt>: handle configuration commands sent by server: see previous section</p>
</li>
</ul>
</blockquote>
</dd>
<dt>saver.py</dt>
<dd><p class="first">binds to <tt class="docutils literal">zmq.PULL</tt> socket on port 5558, to receive all computation results;
results are checked through a <strong>poller</strong>:</p>
<pre class="last literal-block">
while True:
 socks = dict(poller.poll())
 if req_receiver in socks and socks[req_receiver] == zmq.POLLIN:
     message = req_receiver.recv()
     print &quot;Computer requested a save: %s&quot; % message
</pre>
</dd>
</dl>
</div>
</div>
<div class="section" id="fake-mail-form-mailbin">
<span id="fake-mail-form"></span><h1>Fake mail form (mailbin)</h1>
<pre class="literal-block">
#--------------#  #--------------#  #--------------#
|  FakerScript |  |  FakerScript |  |  FakerScript |
+--------------+  +--------------+  +--------------+
|     PUSH     |  |     PUSH     |  |     PUSH     |
'------+-------'  '------+-------'  '------+-------'
  connect:5558      connect:5558      connect:5558
       |                 |                 |
       '-----------------+-----------------'
                         |
                       data
                         |
                         v
                      bind:5558
                  .-------------.
                  |    PULL     |
                  +-------------+
                  |   Mailbin   |
                  #-------------#
</pre>
<p>Pushes fake mail form post data to the <tt class="docutils literal">mailbin</tt> service.
The form data are pushed to a <tt class="docutils literal">zmq.PUSH</tt> socket on port 5558, and it is received
at the <em>Mailbin</em> service (<tt class="docutils literal">zmq.PULL</tt> socket with a <strong>poller</strong>).</p>
</div>
</div>
</body>
</html>
